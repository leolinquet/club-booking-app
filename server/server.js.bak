// server/server.js  (ESM version)
// Run with: npm run dev  (dev script should be: node -r dotenv/config server.js)
import 'dotenv/config';
import express from 'express';
import cors from 'cors';
import helmet from 'helmet';
import bcrypt from 'bcryptjs';
import path from 'path';
import { fileURLToPath } from 'url';

import db, { pool, logDbIdentity, run, q, one, all, prepare, tableExists } from './db.js';
import { tableInfo, addColumnsIfMissing } from './pg_compat.js';
import { sendEmail } from './email/resend.js';



const __filename = fileURLToPath(import.meta.url);
const __dirname  = path.dirname(__filename);

try {
  await addColumnsIfMissing('standings', {
    points: 'points INTEGER DEFAULT 0',
    tournaments_played: 'tournaments_played INTEGER DEFAULT 0'
  })
} catch (e) {
  console.error('Could not ensure standings columns:', e.message)
}


// If your app uses tournament_points, ensure minimal columns exist.
// If you don't use it, you can skip this block entirely.
await addColumnsIfMissing('tournament_points', {
  player_id: 'player_id INTEGER',
  tournament_id: 'tournament_id INTEGER',
  points: 'points INTEGER DEFAULT 0'
})

const app = express();

// ----- Security & platform basics -----
app.enable('trust proxy'); // so req.secure works behind Render/Heroku/etc.

// Security headers early
app.use(
  helmet({
    crossOriginResourcePolicy: { policy: 'cross-origin' },
  })
);

// Environment
const isProd = process.env.NODE_ENV === 'production';

// Force HTTPS in production only
app.use((req, res, next) => {
  if (!isProd) return next();
  const xfProto = req.get('x-forwarded-proto');
  if (req.secure || xfProto === 'https') return next();
  return res.redirect(301, `https://${req.headers.host}${req.originalUrl}`);
});

// ----- CORS (dev-friendly; strict in prod) -----
const allowed = new Set(
  [
    process.env.CLIENT_URL,         // e.g. https://your-site.onrender.com
    process.env.ADMIN_URL,
    'capacitor://localhost',
    // If you have a known static site domain, you can also hardcode it here:
    'https://club-booking-app-1.onrender.com',
  ].filter(Boolean)
);
const allowOnrenderRegex = /^https:\/\/.+\.onrender\.com$/;

// Allow localhost and common LAN IP ranges in dev (so phones on Wi-Fi can test)
const devRegex =
  /^(http:\/\/(localhost|127\.0\.0\.1)(:\d+)?|http:\/\/(?:10|172\.(1[6-9]|2\d|3[01])|192\.168)\.\d+\.\d+(?::\d+)?)/;

const corsOptions = {
  origin(origin, cb) {
    // Non-browser clients like curl/postman send no Origin
    if (!origin) return cb(null, true);

    // Dev: allow localhost + LAN IPs
    if (!isProd && devRegex.test(origin)) return cb(null, true);

    // Prod: only explicit allowlist + *.onrender.com
    if (allowed.has(origin) || allowOnrenderRegex.test(origin)) return cb(null, true);

    return cb(new Error(`CORS blocked for origin: ${origin}`));
  },
  credentials: true,
};

app.use(cors({
  origin: ['http://localhost:5173', 'http://127.0.0.1:5173'],
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'PATCH', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization'],
}));
app.options('*', cors()); // preflight

// Body parser
app.use(express.json());

// env check
app.get('/__envcheck', async (req, res) => {
  const k = process.env.RESEND_API_KEY || '';
  const masked = k ? `${k.slice(0,6)}…${k.slice(-4)}` : '';
  res.json({
    has_RESEND_API_KEY: Boolean(k),
    RESEND_API_KEY_masked: masked,
    FROM_EMAIL: process.env.FROM_EMAIL,
    APP_BASE_URL: process.env.APP_BASE_URL
  });
});

// test send (replace with your real inbox before calling)
// app.post('/__sendtest', express.json(), async (req, res) => {
//   const to = req.body?.to;
//   if (!to) return res.status(400).json({ ok: false, error: 'Provide "to" in JSON body' });

//   const result = await sendEmail({
//     to,
//     subject: 'Test from Club Booking',
//     html: '<p>Hello from Resend ✅</p>',
//   });

//   return res.status(result.ok ? 200 : 500).json(result); // ← don’t wrap in { ok: result }
// });

app.get('/__envcheck', async (req, res) => {
  const k = process.env.RESEND_API_KEY || '';
  res.json({
    has_RESEND_API_KEY: !!k,
    RESEND_API_KEY_masked: k ? `${k.slice(0,6)}…${k.slice(-4)}` : '',
    FROM_EMAIL: process.env.FROM_EMAIL,
    APP_BASE_URL: process.env.APP_BASE_URL
  });
});

// Ensure base tables/columns exist
// function ensureSchema() {
//   // tournament_players.seed
//   const tpCols = db.prepare(`PRAGMA table_info(tournament_players)`).all();
//   if (!tpCols.some(c => c.name === 'seed')) {
//     db.exec(`ALTER TABLE tournament_players ADD COLUMN seed INTEGER`);
//   }

//   // tournaments.seeds_count
//   const tCols = db.prepare(`PRAGMA table_info(tournaments)`).all();
//   if (!tCols.some(c => c.name === 'seeds_count')) {
//     db.exec(`ALTER TABLE tournaments ADD COLUMN seeds_count INTEGER DEFAULT 0`);
//   }
// }
// ensureSchema();

// standings.points, standings.tournaments_played
try {
  const sCols = new Set((await tableInfo('standings')).map(c => c.name));
  if (!sCols.has('points')) {
    await db.prepare(`ALTER TABLE standings ADD COLUMN points INTEGER DEFAULT 0`).run();
    console.log('Added standings.points column');
  }
  if (!sCols.has('tournaments_played')) {
    await db.prepare(`ALTER TABLE standings ADD COLUMN tournaments_played INTEGER DEFAULT 0`).run();
    console.log('Added standings.tournaments_played column');
  }
} catch (e) {
  console.error('Could not ensure standings columns:', e.message);
}

// tournament_points table (idempotent)
db.prepare(`
  CREATE TABLE IF NOT EXISTS tournament_points (
    tournament_id INTEGER NOT NULL,
    round INTEGER NOT NULL,   -- 1=Final, 2=SF, 3=QF, ... (larger number = earlier round)
    points INTEGER NOT NULL,
    PRIMARY KEY (tournament_id, round),
    FOREIGN KEY(tournament_id) REFERENCES tournaments(id) ON DELETE CASCADE
  )
`).run();

// --- Postgres bootstrap for standings & tournament points (no SQLite helpers) ---
async function ensureRankingsSchema() {
  // standings table (per user per club)
  await pool.query(`
    CREATE TABLE IF NOT EXISTS standings (
      id BIGSERIAL PRIMARY KEY,
      user_id BIGINT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
      club_id BIGINT NOT NULL REFERENCES clubs(id) ON DELETE CASCADE,
      points INTEGER NOT NULL DEFAULT 0,
      tournaments_played INTEGER NOT NULL DEFAULT 0,
      UNIQUE(user_id, club_id)
    );
  `);

  // be idempotent if table already existed
  await pool.query(`ALTER TABLE standings ADD COLUMN IF NOT EXISTS points INTEGER NOT NULL DEFAULT 0`);
  await pool.query(`ALTER TABLE standings ADD COLUMN IF NOT EXISTS tournaments_played INTEGER NOT NULL DEFAULT 0`);

  // optional tournament points config (one per club+sport)
  await pool.query(`
    CREATE TABLE IF NOT EXISTS tournament_points (
      id BIGSERIAL PRIMARY KEY,
      club_id BIGINT NOT NULL REFERENCES clubs(id) ON DELETE CASCADE,
      sport TEXT NOT NULL DEFAULT 'tennis',
      r16 INTEGER NOT NULL DEFAULT 0,
      qf  INTEGER NOT NULL DEFAULT 0,
      sf  INTEGER NOT NULL DEFAULT 0,
      f   INTEGER NOT NULL DEFAULT 0,
      w   INTEGER NOT NULL DEFAULT 0,
      UNIQUE (club_id, sport)
    );
  `);
}

// call this once during startup (after pool is imported and ready)
await ensureRankingsSchema();

// -------------------------------
// Utilities
// -------------------------------
function nowDateTime() {
  const d = new Date();
  const date = d.toISOString().slice(0, 10); // YYYY-MM-DD
  const hh = String(d.getHours()).padStart(2, '0');
  const mm = String(d.getMinutes()).padStart(2, '0');
  return { date, time: `${hh}:${mm}` };
}

// -------------------------------
// Auth
// -------------------------------
// ---------- AUTH: register (transactional find-or-create) ----------
// helper: normalize role
const normalizeRole = r => (r === 'manager' ? 'manager' : 'player');

app.post('/auth/register', async (req, res) => {
  try {
    // IMPORTANT: use "username" (not "name")
    const { username, email, password, role } = req.body || {};
    if ((!username && !email) || !password) {
      return res.status(400).json({ error: 'username/email and password required' });
    }

    const targetRole = normalizeRole(role);
    const isManager = targetRole === 'manager';

    // reject duplicates (case-insensitive)
    const dup = await pool.query(
      `SELECT id FROM users
        WHERE ($1 IS NOT NULL AND LOWER(username)=LOWER($1))
           OR ($2 IS NOT NULL AND LOWER(email)=LOWER($2))
        LIMIT 1`,
      [username || null, email || null]
    );
    if (dup.rows.length) {
      return res.status(409).json({ error: 'username or email already exists' });
    }

    const password_hash = await bcrypt.hash(password, 10);

    const ins = await pool.query(
      `INSERT INTO users (username, email, password_hash, role, is_manager)
       VALUES ($1, $2, $3, $4, $5)
       RETURNING id, username, email, role, is_manager`,
      [username?.toLowerCase() || null, email?.toLowerCase() || null, password_hash, targetRole, isManager]
    );

    res.status(201).json({ user: ins.rows[0] });
  } catch (e) {
    console.error('POST /auth/register', e.code || e.message, e);
    res.status(500).json({ error: e.code || 'unexpected error' });
  }
});

app.post('/auth/login', async (req, res) => {
  try {
    const { login, password } = req.body || {};
    if (!login) return res.status(400).json({ error: 'login required' });

    // accept username OR email, case-insensitive
    const r = await pool.query(
      `SELECT id, username, email, role, is_manager, password_hash
         FROM users
        WHERE LOWER(username)=LOWER($1) OR LOWER(email)=LOWER($1)
        LIMIT 1`,
      [login]
    );
    const u = r.rows[0];
    if (!u) return res.status(401).json({ error: 'invalid credentials' });

    if (u.password_hash) {
      const ok = await bcrypt.compare(password || '', u.password_hash);
      if (!ok) return res.status(401).json({ error: 'invalid credentials' });
    } else {
      // (Dev convenience) allow password-less seed users to log in
      // Remove this block if you want to require a password for all users.
    }

    delete u.password_hash;
    res.json({ user: u });
  } catch (e) {
    console.error('POST /auth/login', e.code || e.message, e);
    res.status(500).json({ error: e.code || 'unexpected error' });
  }
});

// -------------------------------
// Tournament helpers
// -------------------------------

// Round numbering convention:
//   round=1 => Final
//   round=2 => Semifinal
//   round=3 => Quarterfinal
//   ... up to round = log2(drawSize)
//
// drawSize must be a power of two from 4..128.

function roundCountFor(drawSize) {
  // e.g., 4->2 rounds; 8->3; 16->4; 128->7
  return Math.log2(drawSize);
}

function genCode() {
  return Math.random().toString(36).slice(2, 8).toUpperCase();
}

function canonicalRounds(drawSize) {
  // returns [R128,R64,R32,R16,QF,SF,F] filtered to needed size, mapped to round number
  const labels = [
    { label: 'R128', size: 128 },
    { label: 'R64',  size:  64 },
    { label: 'R32',  size:  32 },
    { label: 'R16',  size:  16 },
    { label: 'QF',   size:   8 },
    { label: 'SF',   size:   4 },
    { label: 'F',    size:   2 },
  ];
  const needed = labels.filter(l => l.size <= drawSize);
  // map to (roundNumber, label); roundNumber grows with earlier rounds
  // e.g., for draw 16: R16(round=4), QF(3), SF(2), F(1)
  return needed.map((l, idx) => ({
    label: l.label,
    round: needed.length - idx, // final=1
  }));
}

// ---- helpers: canonical bracket order ----
function nextPow2(n){ let p = 1; while (p < n) p <<= 1; return p; }

// 1, N, then recurse halves → produces the standard positions for 1..drawSize
function pairingOrder(drawSize){
  function rec(n){
    if (n === 1) return [1];
    const prev = rec(n/2);
    const mirr = prev.map(x => n + 1 - x);
    return [...prev, ...mirr];
  }
  return rec(drawSize); // 1-based
}

// ---- compute seeds + randomized rest (unchanged idea, tiny tweaks) ----
function computeSeedingOrder({ clubId, sport, playerIds, seedCount }) {
  const rows = db.prepare(`
    SELECT p.id as player_id, s.points as pts
    FROM players p
    LEFT JOIN standings s
      ON s.player_id = p.id AND s.club_id = p.club_id AND s.sport = ?
    WHERE p.club_id = ? AND p.id IN (${playerIds.map(()=>'?').join(',')})
  `).all(sport, clubId, ...playerIds);

  const ptsMap = new Map(rows.map(r => [r.player_id, r.pts ?? 0]));

  // Sort by points desc, stable by id to break ties deterministically
  const ranked = [...playerIds]
    .map(pid => ({ pid, pts: ptsMap.get(pid) ?? 0 }))
    .sort((a,b)=> b.pts - a.pts || (a.pid - b.pid));

  const k = Math.min(seedCount || 0, ranked.length);
  const seeds = ranked.slice(0, k).map(r => r.pid);
  const rest  = ranked.slice(k).map(r => r.pid);

  // Fisher–Yates shuffle for unseeded
  for (let i = rest.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [rest[i], rest[j]] = [rest[j], rest[i]];
  }

  return { seeds, rest };
}

// ---- place seeds into bracket slots; fill others randomly ----
function buildSeededSlots({ playerIds, seedCount }) {
  const drawSize = nextPow2(playerIds.length);
  const { seeds, rest } = computeSeedingOrder({ clubId, sport, playerIds, seedCount });

  const order = pairingOrder(drawSize);       // e.g., [1, N, N/4+1, ...]
  const slots = Array(drawSize).fill(null);   // each entry: { playerId, seed|null }

  // place seeds in canonical positions
  for (let i = 0; i < seeds.length; i++) {
    const pos = order[i] - 1;                 // 0-based slot index
    slots[pos] = { playerId: seeds[i], seed: i + 1 };
  }

  // fill the rest (already shuffled) into remaining open slots
  let u = 0;
  for (let i = 0; i < drawSize && u < rest.length; i++) {
    if (!slots[i]) slots[i] = { playerId: rest[u++], seed: null };
  }

  // any trailing nulls are BYEs if drawSize > entrants
  return { slots, drawSize };
}

// ---- first-round pairing from slots: (0 vs 1), (2 vs 3), ... ----
function makeFirstRoundMatches(slots){
  const matches = [];
  for (let i = 0; i < slots.length; i += 2) {
    matches.push({ p1: slots[i] || null, p2: slots[i+1] || null });
  }
  return matches;
}

function awardPointsOnElimination({ tournamentId, clubId, sport, loserPlayerId, roundNumber }) {
  const row = db.prepare(`
    SELECT points FROM tournament_points WHERE tournament_id=? AND round=?
  `).get(tournamentId, roundNumber);
  const pts = row ? row.points : 0;

  // upsert standings for that (club, sport, player)
  const existing = db.prepare(`
    SELECT id, played, won, drawn, lost, gf, ga, points
    FROM standings WHERE club_id=? AND sport=? AND player_id=? AND season='default'
  `).get(clubId, sport, loserPlayerId);

  if (!existing) {
    db.prepare(`
      INSERT INTO standings (club_id, sport, player_id, season, played, points)
      VALUES (?, ?, ?, 'default', 0, ?)
    `).run(clubId, sport, loserPlayerId, pts);
  } else {
    db.prepare(`UPDATE standings SET points = ? WHERE id = ?`)
      .run(existing.points + pts, existing.id);
  }
}

function awardPointsToChampion({ tournamentId, clubId, sport, winnerPlayerId }) {
  // Final round = 1
  const row = db.prepare(`
    SELECT points FROM tournament_points WHERE tournament_id=? AND round=1
  `).get(tournamentId);
  const pts = row ? row.points : 0;

  const existing = db.prepare(`
    SELECT id, points FROM standings WHERE club_id=? AND sport=? AND player_id=? AND season='default'
  `).get(clubId, sport, winnerPlayerId);

  if (!existing) {
    db.prepare(`
      INSERT INTO standings (club_id, sport, player_id, season, played, points)
      VALUES (?, ?, ?, 'default', 0, ?)
    `).run(clubId, sport, winnerPlayerId, pts);
  } else {
    db.prepare(`UPDATE standings SET points = ? WHERE id = ?`)
      .run(existing.points + pts, existing.id);
  }
}

async function deleteTournamentById(tId) {
  // Delete children first; do NOT modify standings table
  await db.prepare(`DELETE FROM matches WHERE tournament_id=?`).run(tId);
  // tournament_points is optional in some installs
  const hasTP = await tableExists('tournament_points');
  if (hasTP) await db.prepare(`DELETE FROM tournament_points WHERE tournament_id=?`).run(tId);
  await db.prepare(`DELETE FROM tournament_players WHERE tournament_id=?`).run(tId);
  await db.prepare(`DELETE FROM tournaments WHERE id=?`).run(tId);
}

// -------------------------------
// Tournaments & Rankings
// -------------------------------

// Create a single-elim tournament with per-round points config
// body: { name, sport, drawSize, seedCount, pointsByRound: { R128,R64,R32,R16,QF,SF,F,C }, managerId }
app.post('/clubs/:clubId/tournaments', async (req, res) => {
  try {
    const clubId = Number(req.params.clubId);
    const { name, sport, drawSize, seedCount, pointsByRound = {}, managerId } = req.body ?? {};

    // --- basic validation ---------------------------------------------------
    if (!name || !sport || !drawSize || !seedCount || !managerId) {
      return res.status(400).json({ error: 'missing fields' });
    }
    if (![4, 8, 16, 32, 64, 128].includes(Number(drawSize))) {
      return res.status(400).json({ error: 'drawSize must be 4,8,16,32,64,128' });
    }
    if (![2, 4, 8, 16, 32].includes(Number(seedCount))) {
      return res.status(400).json({ error: 'seedCount must be 2,4,8,16,32' });
    }

    // --- manager check ------------------------------------------------------
    const clubRow = await get('SELECT manager_id FROM clubs WHERE id=$1', clubId);
    if (!clubRow || Number(clubRow.manager_id) !== Number(managerId)) {
      return res.status(403).json({ error: 'only club manager can create tournaments' });
    }

    // --- detect available columns (keep writes minimal) ---------------------
    const tCols = (await tableInfo('tournaments')).map(c => c.name);
    const payload = {};
    if (tCols.includes('club_id'))      payload.club_id      = clubId;
    if (tCols.includes('sport'))        payload.sport        = String(sport);
    if (tCols.includes('name'))         payload.name         = String(name);
    if (tCols.includes('status'))       payload.status       = 'active';
    if (tCols.includes('format'))       payload.format       = 'single_elim';
    if (tCols.includes('start_date'))   payload.start_date   = null;
    if (tCols.includes('end_date'))     payload.end_date     = null;
    if (tCols.includes('block_courts')) payload.block_courts = 0;
    if (tCols.includes('draw_size'))    payload.draw_size    = Number(drawSize);
    if (tCols.includes('seed_count'))   payload.seed_count   = Number(seedCount);

    const keys = Object.keys(payload);
    if (!keys.length) {
      return res.status(500).json({ error: 'tournaments table has no compatible columns' });
    }
    const vals = keys.map(k => payload[k]);
    const ph   = keys.map((_, i) => `$${i + 1}`).join(', ');

    // --- duplicate guard (best effort; skip if columns absent) --------------
    try {
      const dup = await get(
        'SELECT id FROM tournaments WHERE club_id=$1 AND sport=$2 AND name=$3',
        payload.club_id, payload.sport, payload.name
      );
      if (dup) {
        return res.status(409).json({ error: 'A tournament with this name and sport already exists for this club.' });
      }
    } catch { /* ignore if any of those columns are missing */ }

    // --- insert tournament ---------------------------------------------------
    const row = await get(
      `INSERT INTO tournaments (${keys.join(', ')}) VALUES (${ph}) RETURNING id`,
      ...vals
    );
    const tId = Number(row.id);

    res.json({ ok: true, tournament: { id: tId, name: String(name), sport: String(sport) } });
  } catch (e) {
    console.error(e);
    res.status(500).json({ error: 'unexpected error' });
  }
});


// body: { playerIds?: number[], userIds?: number[], managerId }
app.post('/tournaments/:id/players', async (req, res) => {
  try {
    const tId = Number(req.params.id);
    const { userIds = [], usernames = [], managerId } = req.body || {};

    const t = await db.prepare('SELECT id, club_id, sport, name FROM tournaments WHERE id=?').get(tId);
    if (!t) return res.status(404).json({ error: `tournament ${tId} not found in DB` });

    // only the club manager can add
    const clubRow = await db.prepare('SELECT manager_id FROM clubs WHERE id=?').get(t.club_id);
    if (!clubRow || Number(clubRow.manager_id) !== Number(managerId)) {
      return res.status(403).json({ error: 'only club manager can add players' });
    }

    // 1) resolve usernames -> user ids
    const ids = new Set(userIds.map(n => Number(n)).filter(Boolean));
    const notFound = [];
    for (const raw of usernames) {
      const name = String(raw).trim();
      if (!name) continue;
      const u = await db.prepare('SELECT id, display_name FROM users WHERE display_name = ?').get(name);
      if (u) ids.add(u.id);
      else notFound.push(name);
    }
    if (ids.size === 0) {
      return res.status(400).json({ error: notFound.length ? `Users not found: ${notFound.join(', ')}` : 'No valid users found' });
    }

    // 2) ensure players row exists for this club+user, then insert that players.id
    for (const uid of ids) {
      // upsert into players (club-scoped identity). display_name defaults to users.name
      await db.prepare(`
        INSERT INTO players (club_id, user_id, display_name)
        SELECT ?, ?, COALESCE(display_name, 'user' || ?) FROM users WHERE id = ?
        ON CONFLICT (club_id, user_id) DO NOTHING
      `).run(t.club_id, Number(uid), Number(uid), Number(uid));


      const p = db.prepare(`
        SELECT id FROM players WHERE club_id=? AND user_id=?
      `).get(t.club_id, Number(uid));

      if (!p) {
        // safety net: if user doesn’t exist, skip with message
        return res.status(400).json({ error: `No player entry could be created for user_id=${uid}` });
      }

      try {
        await db.prepare(`
          INSERT INTO tournament_players (tournament_id, player_id)
          VALUES (?, ?)
          ON CONFLICT (tournament_id, player_id) DO NOTHING
        `).run(tId, p.id);
      } catch (e) {
        console.error('Add player FK error', { tId, uid, playerId: p.id, tournament: t, msg: e.message });
        return res.status(500).json({ error: `FK failed for tournament_id=${tId}, player_id=${p.id}` });
      }
    }

    // return current list using players (and fallback to users.name)
    const current = db.prepare(`
      SELECT tp.player_id, COALESCE(p.display_name, u.display_name) AS display_name
      FROM tournament_players tp
      JOIN players p ON p.id = tp.player_id
      LEFT JOIN users u ON u.id = p.user_id
      WHERE tp.tournament_id=?
      ORDER BY display_name ASC
    `).all(tId);

    res.json({ players: current, notFound });
  } catch (e) {
    console.error('Error in /tournaments/:id/players:', e);
    res.status(500).json({ error: e.message || 'unexpected error' });
  }
});

// Auto-creates Round N matches with seeded placements.
// body: { drawSize, seedCount, managerId }
app.post('/tournaments/:id/generate', async (req, res) => {
  try {
    const tId = Number(req.params.id);
    const { drawSize, seedCount, managerId } = req.body || {};

    const t = await db.prepare('SELECT id, club_id, sport FROM tournaments WHERE id=?').get(tId);
    if (!t) return res.status(404).json({ error: 'tournament not found' });

    const clubRow = await db.prepare('SELECT manager_id FROM clubs WHERE id=?').get(t.club_id);
    if (!clubRow || Number(clubRow.manager_id) !== Number(managerId)) {
      return res.status(403).json({ error: 'only club manager can generate bracket' });
    }

    const N = Number(drawSize);
    if (![4,8,16,32,64,128].includes(N)) {
      return res.status(400).json({ error: 'drawSize must be 4,8,16,32,64,128' });
    }

    // Entrants with points for ranking (0 if none)
    const entrants = db.prepare(`
      SELECT
        tp.player_id                                   AS player_id,
        COALESCE(p.display_name, u.display_name)       AS display_name,
        COALESCE(s.points, 0)                          AS pts
      FROM tournament_players tp
      JOIN players p ON p.id = tp.player_id
      LEFT JOIN users u ON u.id = p.user_id
      LEFT JOIN standings s
        ON s.player_id = tp.player_id AND s.club_id = ?
      WHERE tp.tournament_id = ?
    `).all(t.club_id, tId);

    const M = entrants.length;
    if (M === 0) return res.status(400).json({ error: 'need at least 1 player' });
    if (M > N)   return res.status(400).json({ error: `too many players (${M}); increase draw size or remove players` });

    // Rank entrants
    const ranked = [...entrants].sort((a,b) =>
      (b.pts ?? 0) - (a.pts ?? 0) ||
      a.display_name.localeCompare(b.display_name, undefined, { sensitivity: 'base' }) ||
      (a.player_id - b.player_id)
    );

    // Seed count actually used (cannot exceed entrants)
    let S = Math.min(Number(seedCount) || 0, 32, N, M);

    const seeds = ranked.slice(0, S).map(e => e.player_id);
    const rest  = ranked.slice(S).map(e => e.player_id);

    // Shuffle unseeded (Fisher–Yates)
    for (let i = rest.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [rest[i], rest[j]] = [rest[j], rest[i]];
    }

    // Canonical bracket order builder (1 top, 2 bottom, etc.)
    function positions(size) {
      function build(n) {
        if (n === 2) return [1, 2];
        const prev = build(n / 2);
        const out = [];
        for (let i = 0; i < prev.length; i++) {
          out.push(prev[i]);
          out.push(n + 1 - prev[i]);
        }
        return out;
      }
      return build(size);
    }
    const order = positions(N);

    // 0 = empty, -1 = reserved BYE for a top seed’s opponent
    const slots = new Array(N).fill(0);

    // place seeds by seed index -> slot
    for (let i = 0; i < S; i++) {
      const slotIndex = order[i] - 1;
      slots[slotIndex] = seeds[i];
    }

    // Reserve BYEs for top seeds first
    const byes = N - M;
    let byeAssigned = 0;
    for (let i = 0; i < S && byeAssigned < byes; i++) {
      const sIdx = order[i] - 1;
      const oppIdx = sIdx ^ 1;
      if (slots[oppIdx] === 0) { slots[oppIdx] = -1; byeAssigned++; }
    }

    // Fill remaining with unseeded; any leftover empties remain BYEs
    let rIdx = 0;
    for (let i = 0; i < N && rIdx < rest.length; i++) {
      if (slots[i] === 0) slots[i] = rest[rIdx++];
    }

    // Wipe old matches
    await db.prepare('DELETE FROM matches WHERE tournament_id=?').run(tId);

    // Persist seeds so UI can render badges
    await db.prepare(`UPDATE tournament_players SET seed = NULL WHERE tournament_id = ?`).run(tId);
    const setSeed = db.prepare(`UPDATE tournament_players SET seed = ? WHERE tournament_id = ? AND player_id = ?`);
    seeds.forEach((pid, idx) => setSeed.run(idx + 1, tId, pid)); // 1..S
    await db.prepare(`UPDATE tournaments SET seeds_count = ? WHERE id = ?`).run(S, tId);

    // Insert first round
    const firstRound = Math.log2(N);
    const hasStatus = new Set((await tableInfo('matches')).map(c => c.name)).has('status');
    const insertSQL = hasStatus
      ? `INSERT INTO matches (tournament_id, round, slot, p1_id, p2_id, p1_score, p2_score, winner_id, status)
         VALUES (?, ?, ?, ?, ?, NULL, NULL, NULL, 'scheduled')`
      : `INSERT INTO matches (tournament_id, round, slot, p1_id, p2_id, p1_score, p2_score, winner_id)
         VALUES (?, ?, ?, ?, ?, NULL, NULL, NULL)`;
    const insertMatch = db.prepare(insertSQL);

    for (let s = 0; s < N / 2; s++) {
      const left  = slots[2 * s];
      const right = slots[2 * s + 1];
      const p1 = left  > 0 ? left  : null;  // -1/0 -> NULL (BYE)
      const p2 = right > 0 ? right : null;
      insertMatch.run(tId, firstRound, s, p1, p2);
    }

    // Auto-advance BYEs
    autoAdvanceByes(tId);

    res.json({ ok: true, round: firstRound, matches: N / 2 });
  } catch (e) {
    console.error('Generate bracket error:', e);
    res.status(500).json({ error: 'unexpected error' });
  }
});


app.put('/matches/:id/result', async (req, res) => {
  try {
    const mId = Number(req.params.id);
    const { managerId, p1_score, p2_score } = req.body || {};
    if (!managerId) return res.status(400).json({ error: 'managerId required' });

    const m = await db.prepare('SELECT * FROM matches WHERE id=?').get(mId);
    if (!m) return res.status(404).json({ error: 'match not found' });

    const s1 = Number(p1_score);
    const s2 = Number(p2_score);
    if (!Number.isFinite(s1) || !Number.isFinite(s2)) return res.status(400).json({ error: 'invalid scores' });
    if (s1 === s2) return res.status(400).json({ error: 'scores must not tie' });

    const winnerId = s1 > s2 ? m.p1_id : m.p2_id;

    const mColsInfo = await tableInfo('matches');
    const mCols = new Set(mColsInfo.map(c => c.name));
    const notnull = Object.fromEntries(mColsInfo.map(c => [c.name, c.notnull]));


    const setParts = [];
    const vals = [];
    if (mCols.has('p1_score')) { setParts.push('p1_score=?'); vals.push(s1); }
    if (mCols.has('p2_score')) { setParts.push('p2_score=?'); vals.push(s2); }
    if (mCols.has('winner_id')) { setParts.push('winner_id=?'); vals.push(winnerId); }
    if (mCols.has('status')) setParts.push("status='completed'");
    if (mCols.has('updated_at')) setParts.push('updated_at=CURRENT_TIMESTAMP');
    if (!setParts.length) return res.status(500).json({ error: 'matches table missing expected columns' });
    await db.prepare(`UPDATE matches SET ${setParts.join(', ')} WHERE id=?`).run(...vals, mId);

    const nextRound = Number(m.round) - 1;
    if (Number.isFinite(nextRound) && nextRound >= 1) {
      const hasNextMatchId = mCols.has('next_match_id');
      const hasNextSlot = mCols.has('next_slot');
      const hasP1Id = mCols.has('p1_id');
      const hasP2Id = mCols.has('p2_id');

      if (hasNextMatchId && hasNextSlot && hasP1Id && hasP2Id && m.next_match_id) {
        const slot = Number(m.next_slot) === 2 ? 2 : 1;
        const next = await db.prepare('SELECT * FROM matches WHERE id=?').get(m.next_match_id);
        if (next) {
          const field = slot === 1 ? 'p1_id' : 'p2_id';
          if (next[field] == null) await db.prepare(`UPDATE matches SET ${field}=? WHERE id=?`).run(winnerId, m.next_match_id);
        }
      } else {
        const nextSlot = Math.floor(Number(m.slot) / 2);
        let next = db.prepare('SELECT * FROM matches WHERE tournament_id=? AND round=? AND slot=?')
          .get(m.tournament_id, nextRound, nextSlot);

        const myField = (Number(m.slot) % 2 === 0) ? 'p1_id' : 'p2_id';
        const otherField = myField === 'p1_id' ? 'p2_id' : 'p1_id';
        const myNN = notnull[myField] === 1;
        const otherNN = notnull[otherField] === 1;

        if (!next) {
          const siblingSlot = (Number(m.slot) % 2 === 0) ? Number(m.slot) + 1 : Number(m.slot) - 1;
          const sibling = db.prepare('SELECT * FROM matches WHERE tournament_id=? AND round=? AND slot=?')
            .get(m.tournament_id, m.round, siblingSlot);
          const siblingWinner = sibling && Number(sibling.winner_id) ? Number(sibling.winner_id) : null;

          if (siblingWinner != null) {
            const p1 = myField === 'p1_id' ? winnerId : siblingWinner;
            const p2 = myField === 'p1_id' ? siblingWinner : winnerId;
            if (mCols.has('status')) {
              db.prepare(`INSERT INTO matches (tournament_id, round, slot, p1_id, p2_id, p1_score, p2_score, winner_id, status)
                          VALUES (?, ?, ?, ?, ?, NULL, NULL, NULL, 'scheduled')`)
                .run(m.tournament_id, nextRound, nextSlot, p1, p2);
            } else {
              db.prepare(`INSERT INTO matches (tournament_id, round, slot, p1_id, p2_id, p1_score, p2_score, winner_id)
                          VALUES (?, ?, ?, ?, ?, NULL, NULL, NULL)`)
                .run(m.tournament_id, nextRound, nextSlot, p1, p2);
            }
          } else if (!myNN || !otherNN) {
            const p1 = myField === 'p1_id' ? winnerId : null;
            const p2 = myField === 'p1_id' ? null : winnerId;
            if (mCols.has('status')) {
              db.prepare(`INSERT INTO matches (tournament_id, round, slot, p1_id, p2_id, p1_score, p2_score, winner_id, status)
                          VALUES (?, ?, ?, ?, ?, NULL, NULL, NULL, 'scheduled')`)
                .run(m.tournament_id, nextRound, nextSlot, p1, p2);
            } else {
              db.prepare(`INSERT INTO matches (tournament_id, round, slot, p1_id, p2_id, p1_score, p2_score, winner_id)
                          VALUES (?, ?, ?, ?, ?, NULL, NULL, NULL)`)
                .run(m.tournament_id, nextRound, nextSlot, p1, p2);
            }
          }
        } else {
          const field = myField;
          if (next[field] == null) await db.prepare(`UPDATE matches SET ${field}=? WHERE id=?`).run(winnerId, next.id);
        }
      }
    } else {
      const tCols = new Set((await tableInfo('tournaments')).map(c => c.name));
      const tParts = [];
      const tVals = [];
      if (tCols.has('status')) tParts.push("status=?"), tVals.push('completed');
      if (tCols.has('end_date')) tParts.push("end_date=COALESCE(end_date, now())");
      if (tParts.length) await db.prepare(`UPDATE tournaments SET ${tParts.join(', ')} WHERE id=?`).run(...tVals, m.tournament_id);
      awardTournamentPoints(m.tournament_id);
    }

    res.json({ ok: true, winner_id: winnerId });
  } catch (e) {
    console.error('Save result error:', e);
    res.status(500).json({ error: 'unexpected error' });
  }
});

// List tournaments for a club (filter by status optional: 'active'|'completed')
app.get('/clubs/:clubId/tournaments', async (req, res) => {
  try {
    const clubId = Number(req.params.clubId);
    const { status } = req.query;
    let rows = db.prepare(`
      SELECT * FROM tournaments WHERE club_id=? ORDER BY id DESC
    `).all(clubId);

    if (status === 'completed') rows = rows.filter(r => r.end_date != null);
    if (status === 'active')    rows = rows.filter(r => r.end_date == null);

    res.json(rows);
  } catch (e) {
    console.error(e);
    res.status(500).json({ error: 'unexpected error' });
  }
});

// Full bracket snapshot
// GET /tournaments/:id
app.get('/tournaments/:id', async (req, res) => {
  try {
    const tId = Number(req.params.id);

    const tournament = db.prepare(`
      SELECT id, club_id, name, sport, seeds_count, end_date
      FROM tournaments
      WHERE id = ?
    `).get(tId);
    if (!tournament) return res.status(404).json({ error: 'tournament not found' });

    const players = db.prepare(`
      SELECT
        tp.player_id AS id,
        COALESCE(p.display_name, u.display_name) AS display_name,
        tp.seed
      FROM tournament_players tp
      JOIN players p ON p.id = tp.player_id
      LEFT JOIN users u ON u.id = p.user_id
      WHERE tp.tournament_id = ?
      ORDER BY (tp.seed IS NULL), tp.seed, display_name COLLATE NOCASE
    `).all(tId);

    const matches = db.prepare(`
      SELECT id, tournament_id, round, slot,
             p1_id, p2_id, p1_score, p2_score, winner_id,
             COALESCE(status,'scheduled') AS status
      FROM matches
      WHERE tournament_id = ?
      ORDER BY round DESC, slot ASC
    `).all(tId);

    const hasTP = await tableExists('tournament_points');
    const points = hasTP
      ? await db.prepare(`
          SELECT tp.player_id, COALESCE(p.display_name, u.display_name) AS name, tp.points, tp.placement
            FROM tournament_points tp
            JOIN players p ON p.id = tp.player_id
            LEFT JOIN users u ON u.id = p.user_id
            WHERE tp.tournament_id = ?
            ORDER BY tp.points DESC, name ASC
        `).all(tId)
      : [];

    res.json({ tournament, players, matches, points });
  } catch (e) {
    console.error('Tournament detail error:', e);
    res.status(500).json({ error: 'unexpected error' });
  }
});



// Get standings (rankings) for a club
app.get('/clubs/:clubId/standings', async (req, res) => {
  try {
    const clubId = Number(req.params.clubId);
    const rows = db.prepare(`
      SELECT
        s.player_id,
        COALESCE(p.display_name, u.display_name) AS name,
        s.tournaments_played,
        s.points
      FROM standings s
      JOIN players p ON p.id = s.player_id
      LEFT JOIN users u ON u.id = p.user_id
      WHERE s.club_id = ?
      ORDER BY s.points DESC, name ASC
    `).all(clubId);

    res.json(rows);
  } catch (e) {
    console.error(e);
    res.status(500).json({ error: 'unexpected error' });
  }
});

// Reset all standings for a club (manager only). Body: { managerId, confirm: "reset" }
app.post('/clubs/:clubId/standings/reset', async (req, res) => {
  try {
    const clubId = Number(req.params.clubId);
    const { managerId, confirm } = req.body || {};
    if (confirm !== 'reset') {
      return res.status(400).json({ error: 'type "reset" to confirm' });
    }
    const clubRow = await db.prepare('SELECT manager_id FROM clubs WHERE id=?').get(clubId);
    if (!clubRow || Number(clubRow.manager_id) !== Number(managerId)) {
      return res.status(403).json({ error: 'only club manager can reset standings' });
    }

    // You asked to have "no players there anymore" after reset
    await db.prepare(`DELETE FROM standings WHERE club_id=?`).run(clubId);
    res.json({ ok: true });
  } catch (e) {
    console.error(e);
    res.status(500).json({ error: 'unexpected error' });
  }
});


  // tournament → club
  const t = await get(
    `SELECT t.id, t.club_id
       FROM tournaments t
      WHERE t.id = $1`,
    tournamentId
  );
  if (!t) return;

  // Gather completed matches for this tournament
  const matches = await all(
    `SELECT id, round, slot, p1_id, p2_id, winner_id
       FROM matches
      WHERE tournament_id = $1
        AND winner_id IS NOT NULL`,
    tournamentId
  );
  if (!matches.length) return;

  // Determine champion (winner of final = round 1)
  const final = matches.find(m => Number(m.round) === 1);
  const championId = final?.winner_id ? Number(final.winner_id) : null;

  // Compute per-player aggregates: played, placement & points
  // You decide points policy here (e.g., give losers-by-round points and champion bonus).
  // For simplicity: losers get round-based points (hardcode or derive),
  // champion gets extra "placement" and points.

  // Example policy (adjust as you like; persisted per-player, not per-round):
  const ROUND_POINTS = new Map([
    [7, 1],  // R128
    [6, 2],  // R64
    [5, 4],  // R32
    [4, 8],  // R16
    [3, 12], // QF
    [2, 18], // SF
    [1, 26], // Finalist (loser of final)
  ]);
  const CHAMPION_BONUS = 40; // champion extra

  const agg = new Map(); // player_id -> { played:1, points:sum }
  const add = (pid, pts = 0) => {
    if (!pid) return;
    const cur = agg.get(pid) || { played: 0, points: 0 };
    cur.played = 1;
    cur.points += Number(pts || 0);
    agg.set(pid, cur);
  };

  // Every completed match: both appear as "played", loser gets round points
  for (const m of matches) {
    add(m.p1_id, 0);
    add(m.p2_id, 0);
    const loser = Number(m.winner_id) === Number(m.p1_id) ? m.p2_id : m.p1_id;
    add(loser, ROUND_POINTS.get(Number(m.round)) || 0);
  }
  if (championId) add(championId, CHAMPION_BONUS);

  // Upsert per-player tournament_points and club standings (006)
  await run('BEGIN');
  try {
    for (const [playerId, v] of agg.entries()) {
      // Tournament points (per player)
      await run(
        `INSERT INTO tournament_points (tournament_id, player_id, points, placement)
         VALUES ($1, $2, $3, NULL)
         ON CONFLICT (tournament_id, player_id)
         DO UPDATE SET points = tournament_points.points + EXCLUDED.points`,
        tournamentId, playerId, v.points
      );

      // Club standings (per player)
      await run(
        `INSERT INTO standings (club_id, player_id, tournaments_played, points)
         VALUES ($1, $2, $3, $4)
         ON CONFLICT (club_id, player_id)
         DO UPDATE SET
           tournaments_played = standings.tournaments_played + EXCLUDED.tournaments_played,
           points             = standings.points + EXCLUDED.points`,
        t.club_id, playerId, v.played, v.points
      );
    }
    await run('COMMIT');
  } catch (e) {
    await run('ROLLBACK');
    throw e;
  }
}


// GET /tournaments/:id/joined?userId=123
app.get('/tournaments/:id/joined', async (req, res) => {
  try {
    const tId = Number(req.params.id);
    const userId = Number(req.query.userId);
    if (!userId) return res.status(400).json({ joined: false });

    const t = await db.prepare(`SELECT id, club_id FROM tournaments WHERE id=?`).get(tId);
    if (!t) return res.status(404).json({ error: 'tournament not found' });

    // find or create the player's club profile
    let player = db.prepare(`SELECT id FROM players WHERE club_id=? AND user_id=?`)
      .get(t.club_id, userId);

    if (!player) return res.json({ joined: false });

    const row = db.prepare(`
      SELECT 1 FROM tournament_players WHERE tournament_id=? AND player_id=? LIMIT 1
    `).get(tId, player.id);

    res.json({ joined: !!row });
  } catch (e) {
    console.error('joined error', e);
    res.status(500).json({ error: 'unexpected error' });
  }
});

// POST /tournaments/:id/signin  { userId }
app.post('/tournaments/:id/signin', async (req, res) => {
  try {
    const tId = Number(req.params.id);
    const { userId } = req.body || {};
    if (!userId) return res.status(400).json({ error: 'userId required' });

    const t = await db.prepare(`SELECT id, club_id, end_date FROM tournaments WHERE id=?`).get(tId);
    if (!t) return res.status(404).json({ error: 'tournament not found' });

    const hasMatches = await db.prepare(`SELECT COUNT(*) AS c FROM matches WHERE tournament_id=?`).get(tId).c > 0;
    if (hasMatches) return res.status(400).json({ error: 'sign-ups are closed (draw already generated)' });
    if (t.end_date) return res.status(400).json({ error: 'tournament is completed' });

    // find or create player profile in this club
    let player = db.prepare(`SELECT id FROM players WHERE club_id=? AND user_id=?`)
      .get(t.club_id, Number(userId));
    if (!player) {
      const u = await db.prepare(`SELECT display_name FROM users WHERE id=?`).get(Number(userId));
      const pCols = new Set((await tableInfo('players')).map(c => c.name));
      const ins = pCols.has('display_name')
        ? db.prepare(`INSERT INTO players (club_id, user_id, display_name) VALUES (?, ?, ?) RETURNING id`)
        : db.prepare(`INSERT INTO players (club_id, user_id) VALUES (?, ?) RETURNING id`);

      const result = pCols.has('display_name')
        ? await ins.get(t.club_id, Number(userId), u?.display_name ?? `user${userId}`)
        : await ins.get(t.club_id, Number(userId));
      player = { id: Number(result.id) };
    }

      await db.prepare(`
        INSERT INTO tournament_players (tournament_id, player_id)
        VALUES (?, ?)
        ON CONFLICT (tournament_id, player_id) DO NOTHING
      `).run(tId, player.id);


    // add to tournament
      await db.prepare(`
        INSERT INTO standings (club_id, player_id, tournaments_played, points)
        VALUES (?, ?, 0, 0)
        ON CONFLICT (club_id, player_id) DO NOTHING
      `).run(t.club_id, player.id);

    res.json({ ok: true });
  } catch (e) {
    console.error('signin error', e);
    res.status(500).json({ error: 'unexpected error' });
  }
});

// DELETE /tournaments/:id/signin  { userId }
app.delete('/tournaments/:id/signin', async (req, res) => {
  try {
    const tId = Number(req.params.id);
    const { userId } = req.body || {};
    if (!userId) return res.status(400).json({ error: 'userId required' });

    const t = await db.prepare(`SELECT id, club_id FROM tournaments WHERE id=?`).get(tId);
    if (!t) return res.status(404).json({ error: 'tournament not found' });

    const hasMatches = await db.prepare(`SELECT COUNT(*) AS c FROM matches WHERE tournament_id=?`).get(tId).c > 0;
    if (hasMatches) return res.status(400).json({ error: 'cannot withdraw (draw already generated)' });

    const player = db.prepare(`SELECT id FROM players WHERE club_id=? AND user_id=?`)
      .get(t.club_id, Number(userId));
    if (!player) return res.json({ ok: true }); // nothing to do

    db.prepare(`DELETE FROM tournament_players WHERE tournament_id=? AND player_id=?`)
      .run(tId, player.id);

    res.json({ ok: true });
  } catch (e) {
    console.error('withdraw error', e);
    res.status(500).json({ error: 'unexpected error' });
  }
});

// after you've built `slots` with some empty holes (0 or null = BYE):
async function autoAdvanceByes(tId) {
  const hasStatus = new Set((await tableInfo('matches')).map(c => c.name)).has('status');
  const updSQL = hasStatus
    ? `UPDATE matches SET winner_id=?, status='completed' WHERE id=?`
    : `UPDATE matches SET winner_id=? WHERE id=?`;

  const ms = await db.prepare(`SELECT id, round, slot, p1_id, p2_id FROM matches WHERE tournament_id=? ORDER BY round DESC, slot ASC`).all(tId);
  for (const m of ms) {
    const byeP1 = !m.p1_id, byeP2 = !m.p2_id;
    if ((byeP1 ^ byeP2)) { // exactly one is bye
      const winner = m.p1_id || m.p2_id;
      await db.prepare(updSQL).run(winner, m.id);
      // feed forward deterministically
      const nextRound = m.round - 1;
      if (nextRound >= 1) {
        const nextSlot = Math.floor(m.slot/2);
        let next = db.prepare(`SELECT id,p1_id,p2_id FROM matches WHERE tournament_id=? AND round=? AND slot=?`)
          .get(tId, nextRound, nextSlot);
        if (!next) {
          const ins = hasStatus
            ? `INSERT INTO matches (tournament_id,round,slot,p1_id,p2_id,p1_score,p2_score,winner_id,status)
               VALUES (?,?,?,?,?,NULL,NULL,NULL,'scheduled')`
            : `INSERT INTO matches (tournament_id,round,slot,p1_id,p2_id,p1_score,p2_score,winner_id)
               VALUES (?,?,?,?,?,NULL,NULL,NULL)`;
          await db.prepare(ins).run(tId, nextRound, nextSlot, null, null);
          next = db.prepare(`SELECT id,p1_id,p2_id FROM matches WHERE tournament_id=? AND round=? AND slot=?`)
            .get(tId, nextRound, nextSlot);
        }
        const field = (m.slot % 2 === 0) ? 'p1_id' : 'p2_id';
        if (next[field] == null) await db.prepare(`UPDATE matches SET ${field}=? WHERE id=?`).run(winner, next.id);
      }
    }
  }
}


// DELETE /tournaments/:id/players/:playerId?managerId=999
app.delete('/tournaments/:id/players/:playerId', async (req, res) => {
  try {
    const tId = Number(req.params.id);
    const playerId = Number(req.params.playerId);
    const managerId = Number(req.query.managerId);

    const t = await db.prepare(`SELECT id, club_id FROM tournaments WHERE id=?`).get(tId);
    if (!t) return res.status(404).json({ error: 'tournament not found' });
    const clubRow = await db.prepare(`SELECT manager_id FROM clubs WHERE id=?`).get(t.club_id);
    if (!clubRow || Number(clubRow.manager_id) !== managerId) {
      return res.status(403).json({ error: 'only club manager can modify entrants' });
    }

    const hasMatches = await db.prepare(`SELECT COUNT(*) AS c FROM matches WHERE tournament_id=?`).get(tId).c > 0;
    if (hasMatches) return res.status(400).json({ error: 'cannot remove after draw is generated' });

    await db.prepare(`DELETE FROM tournament_players WHERE tournament_id=? AND player_id=?`).run(tId, playerId);
    res.json({ ok: true });
  } catch (e) {
    console.error('remove entrant error', e);
    res.status(500).json({ error: 'unexpected error' });
  }
});

// DELETE /tournaments/:id?managerId=123
app.delete('/tournaments/:id', async (req, res) => {
  try {
    const tId = Number(req.params.id);
    const managerId = Number(req.query.managerId);
    const t = await db.prepare(`SELECT id, club_id, name FROM tournaments WHERE id=?`).get(tId);
    if (!t) return res.status(404).json({ error: 'tournament not found' });

    const clubRow = await db.prepare(`SELECT manager_id FROM clubs WHERE id=?`).get(t.club_id);
    if (!clubRow || Number(clubRow.manager_id) !== managerId) {
      return res.status(403).json({ error: 'only club manager can delete tournaments' });
    }

    deleteTournamentById(tId);
    res.json({ ok: true, deleted: 1, ids: [tId] });
  } catch (e) {
    console.error('delete tournament error', e);
    res.status(500).json({ error: 'unexpected error' });
  }
});

// DELETE /clubs/:clubId/tournaments?status=active|completed|all&managerId=123
app.delete('/clubs/:clubId/tournaments', async (req, res) => {
  try {
    const clubId = Number(req.params.clubId);
    const status = String(req.query.status || 'all').toLowerCase();
    const managerId = Number(req.query.managerId);

    const clubRow = await db.prepare(`SELECT manager_id FROM clubs WHERE id=?`).get(clubId);
    if (!clubRow || Number(clubRow.manager_id) !== managerId) {
      return res.status(403).json({ error: 'only club manager can delete tournaments' });
    }

    let where = `club_id = ?`;
    if (status === 'active') where += ` AND end_date IS NULL`;
    else if (status === 'completed') where += ` AND end_date IS NOT NULL`;
    // 'all' = no extra filter

    const ids = await db.prepare(`SELECT id FROM tournaments WHERE ${where}`).all(clubId).map(r => r.id);
    if (ids.length === 0) return res.json({ ok: true, deleted: 0, ids: [] });

    const tx = db.transaction((arr) => {
      for (const id of arr) deleteTournamentById(id);
    });
    tx(ids);

    res.json({ ok: true, deleted: ids.length, ids });
  } catch (e) {
    console.error('bulk delete tournaments error', e);
    res.status(500).json({ error: 'unexpected error' });
  }
});

// -------------------------------
// Clubs & Membership
// -------------------------------
// Create a club
app.post('/clubs', async (req, res) => {
  try {
    // accept either { managerId } or { userId } from the client
    const { name, managerId: mid, userId } = req.body || {};
    const managerId = Number(mid ?? userId);

    if (!name || !managerId) {
      return res.status(400).json({ error: 'name and managerId (or userId) required' });
    }

    // make sure clubs has the columns we need (idempotent)
    await pool.query(`ALTER TABLE clubs ADD COLUMN IF NOT EXISTS code TEXT UNIQUE`);
    await pool.query(`ALTER TABLE clubs ADD COLUMN IF NOT EXISTS sport TEXT NOT NULL DEFAULT 'tennis'`);
    await pool.query(`ALTER TABLE clubs ADD COLUMN IF NOT EXISTS manager_id BIGINT`);

    // promote user to manager (idempotent)
    await pool.query(`UPDATE users SET role='manager', is_manager=true WHERE id=$1`, [managerId]);

    // create a unique code and insert the club
    const genCode = () => Math.random().toString(36).slice(2, 8).toUpperCase();
    let club = null;
    let code = genCode();

    for (let i = 0; i < 6; i++) {
      const tryInsert = await pool.query(
        `INSERT INTO clubs (name, sport, manager_id, code)
         VALUES ($1, 'tennis', $2, $3)
         ON CONFLICT (code) DO NOTHING
         RETURNING id, name, sport, manager_id, code`,
        [name, managerId, code]
      );
      if (tryInsert.rows.length) {
        club = tryInsert.rows[0];
        break;
      }
      code = genCode();
    }

    if (!club) return res.status(500).json({ error: 'could not generate unique club code' });

    // ensure the manager link exists
    await pool.query(
      `INSERT INTO user_clubs (user_id, club_id, role)
       VALUES ($1, $2, 'manager')
       ON CONFLICT DO NOTHING`,
      [managerId, club.id]
    );

    return res.status(201).json(club);
  } catch (e) {
    console.error('POST /clubs', e);
    return res.status(500).json({ error: 'unexpected error' });
  }
});

app.get('/users/:id', async (req, res) => {
  try {
    const { rows } = await pool.query(
      `SELECT id, username, email, role, is_manager, email_verified_at
       FROM users WHERE id=$1`,
      [req.params.id]
    );
    if (!rows.length) return res.status(404).json({ error: 'not found' });
    res.json(rows[0]);
  } catch (e) {
    console.error('GET /users/:id', e);
    res.status(500).json({ error: 'unexpected error' });
  }
});

app.post('/clubs/join', async (req, res) => {
  try {
    const { code, userId } = req.body || {};
    if (!code || !userId) return res.status(400).json({ error: 'code and userId required' });

    const c = await pool.query(
      `SELECT id, name, sport, manager_id, code
         FROM clubs
        WHERE code=$1`,
      [code.trim().toUpperCase()]
    );
    if (!c.rows.length) return res.status(404).json({ error: 'invalid code' });

    const club = c.rows[0];
    await pool.query(
      `INSERT INTO user_clubs (user_id, club_id, role)
       VALUES ($1,$2,'player')
       ON CONFLICT DO NOTHING`,
      [userId, club.id]
    );
    res.json({ club });
  } catch (e) {
    console.error('POST /clubs/join', e);
    res.status(500).json({ error: 'unexpected error' });
  }
});

app.get('/users/:id/club', async (req, res) => {
  try {
    const { id } = req.params;
    const { rows } = await pool.query(
      `WITH all_clubs AS (
         SELECT c.id, c.name, c.sport, c.manager_id
           FROM clubs c
          WHERE c.manager_id = $1
         UNION
         SELECT c.id, c.name, c.sport, c.manager_id
           FROM user_clubs uc
           JOIN clubs c ON c.id = uc.club_id
          WHERE uc.user_id = $1
       )
       SELECT * FROM all_clubs
       ORDER BY id
       LIMIT 1`,
      [id]
    );
    if (!rows.length) return res.status(404).json({ error: 'no club' });
    res.json(rows[0]);
  } catch (e) {
    console.error('GET /users/:id/club', e);
    res.status(500).json({ error: 'unexpected error' });
  }
});

// GET /users/:id/clubs  (plural)
app.get('/users/:id/clubs', async (req, res) => {
  try {
    const { id } = req.params;
    const { rows } = await pool.query(
      `SELECT c.id, c.name, c.sport, c.manager_id
         FROM clubs c
        WHERE c.manager_id = $1
        UNION
       SELECT c.id, c.name, c.sport, c.manager_id
         FROM user_clubs uc
         JOIN clubs c ON c.id = uc.club_id
        WHERE uc.user_id = $1
        ORDER BY id`,
      [id]
    );
    res.json(rows); // [] if none
  } catch (e) {
    console.error('GET /users/:id/clubs', e);
    res.status(500).json({ error: 'unexpected error' });
  }
});
// -------------------------------
// Club Sports CRUD
// -------------------------------
app.get('/clubs/:clubId/sports', async (req, res) => {
  try {
    const clubId = Number(req.params.clubId);
    const rows = await db.prepare('SELECT * FROM club_sports WHERE club_id = ? ORDER BY id ASC').all(clubId);
    res.json(rows);
  } catch (e) {
    console.error(e);
    res.status(500).json({ error: 'unexpected error' });
  }
});

// Type-safe: owner OR explicit user_clubs manager
async function isClubManager(userId, clubId) {
  const uid = Number(userId);
  const cid = Number(clubId);
  if (!uid || !cid) return false;

  // ONE query -> boolean; avoids bigint vs number issues entirely
  const { rows } = await pool.query(
    `SELECT
       EXISTS (SELECT 1 FROM clubs      WHERE id = $1 AND manager_id = $2)
       OR
       EXISTS (SELECT 1 FROM user_clubs WHERE club_id = $1 AND user_id = $2 AND role = 'manager')
       AS ok`,
    [cid, uid]
  );

  const ok = !!rows[0]?.ok;
  console.log('isClubManager?', { clubId: cid, userId: uid, ok });
  return ok;
}

app.post('/clubs/:clubId/sports', async (req, res) => {
  try {
    const clubId = Number(req.params.clubId);
    const { userId, sport, courts, openHour, closeHour, slotMinutes } = req.body || {};
    if (!userId || !sport) return res.status(400).json({ error: 'userId and sport are required' });

    const ok = await isClubManager(userId, clubId);
    if (!ok) return res.status(403).json({ error: 'only club manager can modify sports' });

    // Ensure table + columns exist (idempotent)
    await pool.query(`
      CREATE TABLE IF NOT EXISTS club_sports(
        club_id BIGINT NOT NULL REFERENCES clubs(id) ON DELETE CASCADE,
        sport   TEXT   NOT NULL
      )`);
    await pool.query(`ALTER TABLE club_sports ADD COLUMN IF NOT EXISTS courts INT`);
    await pool.query(`ALTER TABLE club_sports ADD COLUMN IF NOT EXISTS open_hour INT`);
    await pool.query(`ALTER TABLE club_sports ADD COLUMN IF NOT EXISTS close_hour INT`);
    await pool.query(`ALTER TABLE club_sports ADD COLUMN IF NOT EXISTS slot_minutes INT`);
    // Ensure the unique key matches our ON CONFLICT
    await pool.query(`
      DO $$
      BEGIN
        IF NOT EXISTS (
          SELECT 1 FROM pg_indexes
           WHERE tablename='club_sports'
             AND indexname='club_sports_club_id_sport_key'
        ) THEN
          -- create a unique index on (club_id, sport) if it's missing
          CREATE UNIQUE INDEX club_sports_club_id_sport_key
            ON club_sports (club_id, sport);
        END IF;
      END$$;`);

    const s  = String(sport).toLowerCase();
    const cs = Number(courts);
    const oh = Number(openHour);
    const ch = Number(closeHour);
    const sm = Number(slotMinutes);

    await pool.query(
      `INSERT INTO club_sports (club_id, sport, courts, open_hour, close_hour, slot_minutes)
       VALUES ($1, $2, $3, $4, $5, $6)
       ON CONFLICT (club_id, sport) DO UPDATE
         SET courts=EXCLUDED.courts,
             open_hour=EXCLUDED.open_hour,
             close_hour=EXCLUDED.close_hour,
             slot_minutes=EXCLUDED.slot_minutes`,
      [clubId, s, cs, oh, ch, sm]
    );

    console.log('POST /clubs/:id/sports payload', {
      clubId,
      userId,
      sport,
      courts,
      openHour,
      closeHour,
      slotMinutes
    });

    res.json({ ok: true });
  } catch (e) {
    console.error('POST /clubs/:clubId/sports ->', e.code || '', e.message);
    res.status(500).json({ error: 'unexpected error' });
  }
});

app.put('/clubs/:clubId/sports/:id', async (req, res) => {
  try {
    const clubId = Number(req.params.clubId);
    const id = Number(req.params.id);
    const { sport, courts, openHour, closeHour, slotMinutes, managerId } = req.body || {};

    const row = await db.prepare('SELECT manager_id FROM clubs WHERE id = ?').get(clubId);
    if (!row || Number(row.manager_id) !== Number(managerId)) {
      return res.status(403).json({ error: 'only club manager can modify sports' });
    }

    db.prepare(`
      UPDATE club_sports
      SET sport = ?, courts = ?, open_hour = ?, close_hour = ?, slot_minutes = ?
      WHERE id = ? AND club_id = ?
    `).run(String(sport), Number(courts), Number(openHour), Number(closeHour), Number(slotMinutes), id, clubId);

    const updated = await db.prepare('SELECT * FROM club_sports WHERE id = ?').get(id);
    res.json(updated);
  } catch (e) {
    console.error(e);
    res.status(500).json({ error: 'unexpected error' });
  }
});

app.delete('/clubs/:clubId/sports/:id', async (req, res) => {
  try {
    const clubId = Number(req.params.clubId);
    const id = Number(req.params.id);
    const { managerId } = req.body || {};

    const row = await db.prepare('SELECT manager_id FROM clubs WHERE id = ?').get(clubId);
    if (!row || Number(row.manager_id) !== Number(managerId)) {
      return res.status(403).json({ error: 'only club manager can delete sports' });
    }

    await db.prepare('DELETE FROM club_sports WHERE id = ? AND club_id = ?').run(id, clubId);
    res.json({ ok: true });
  } catch (e) {
    console.error(e);
    res.status(500).json({ error: 'unexpected error' });
  }
});

// -------------------------------
// Availability grid
// -------------------------------
app.get('/availability', async (req, res) => {
  try {
    const clubId = Number(req.query.clubId);
    const sport = String(req.query.sport || '');
    const date = String(req.query.date || '');
    const userId = req.query.userId ? Number(req.query.userId) : null;

    const cfg = await db.prepare('SELECT * FROM club_sports WHERE club_id=? AND sport=?').get(clubId, sport);
    if (!cfg) return res.status(404).json({ error: 'sport not configured for this club' });

    const clubRow = await db.prepare('SELECT manager_id FROM clubs WHERE id = ?').get(clubId);
    const isOwnClubManager = clubRow && Number(clubRow.manager_id) === Number(userId);

    // Build time slots based on slot_minutes
    const times = [];
    const step = Number(cfg.slot_minutes);
    let cur = Number(cfg.open_hour) * 60;
    const end = Number(cfg.close_hour) * 60;
    while (cur < end) {
      const hh = String(Math.floor(cur / 60)).padStart(2, '0');
      const mm = String(cur % 60).padStart(2, '0');
      times.push(`${hh}:${mm}`);
      cur += step;
    }

    const bookings = await all(`
      SELECT b.id, b.court_index, b.time, b.user_id, u.username AS booked_by
      FROM bookings b
      LEFT JOIN users u ON u.id = b.user_id
      WHERE b.club_id=$1 AND b.sport=$2 AND b.date=$3
    `, clubId, sport, date);



    const bookedSet = new Set(bookings.map(b => `${b.court_index}@${b.time}`));
    const ownedSet = userId != null
      ? new Set(bookings.filter(b => b.user_id === userId).map(b => `${b.court_index}@${b.time}`))
      : new Set();
    const idMap = new Map(bookings.map(b => [`${b.court_index}@${b.time}`, b.id]));
    const nameMap = new Map(bookings.map(b => [`${b.court_index}@${b.time}`, b.booked_by || null]));

    const grid = times.map(t => ({
      time: t,
      courts: Array.from({ length: Number(cfg.courts) }).map((_, idx) => {
        const key = `${idx}@${t}`;
        return {
          courtIndex: idx,
          booked: bookedSet.has(key),
          owned: ownedSet.has(key),
          bookingId: idMap.get(key) || null,
          ...(isOwnClubManager && bookedSet.has(key) ? { bookedBy: nameMap.get(key) || null } : {})
        };
      })
    }));

    res.json({ cfg: { courts: Number(cfg.courts) }, slots: grid });
  } catch (e) {
    console.error(e);
    res.status(500).json({ error: 'unexpected error' });
  }
});

// -------------------------------
// Book / Cancel
// -------------------------------
app.post('/book', async (req, res) => {
  try {
    const { clubId, sport, courtIndex, date, time, userId, asUsername } = req.body || {};
    if (clubId == null || !sport || courtIndex == null || !date || !time || userId == null) {
      return res.status(400).json({ error: 'missing fields' });
    }

    const clubRow = await db.prepare('SELECT manager_id FROM clubs WHERE id = ?').get(Number(clubId));
    const isOwnClubManager = clubRow && Number(clubRow.manager_id) === Number(userId);

    let targetUserId = Number(userId);
    if (asUsername !== undefined && asUsername !== null) {
      if (!isOwnClubManager) {
        return res.status(403).json({ error: 'Only the club manager can assign bookings to other users.' });
      }
      const u = await db.prepare('SELECT id FROM users WHERE username = ?').get(String(asUsername).trim());
      if (!u) return res.status(400).json({ error: 'User not found' });
      targetUserId = u.id;
    }

    // enforce "1 active booking" for regular users only
    const { date: curDate, time: curTime } = nowDateTime();
    const hasActive = db.prepare(`
      SELECT 1 FROM bookings
      WHERE user_id = ?
        AND club_id = ?
        AND (date > ? OR (date = ? AND time >= ?))
      LIMIT 1
    `).get(Number(targetUserId), Number(clubId), curDate, curDate, curTime);
    if (!isOwnClubManager && hasActive) {
      return res.status(409).json({ error: 'You already have an active booking. Cancel it or wait until it has passed.' });
    }

    const dup = db.prepare(`
      SELECT 1 FROM bookings
      WHERE club_id = ? AND sport = ? AND court_index = ? AND date = ? AND time = ?
      LIMIT 1
    `).get(Number(clubId), String(sport), Number(courtIndex), String(date), String(time));
    if (dup) return res.status(409).json({ error: 'slot already booked' });

    db.prepare(`
      INSERT INTO bookings (club_id, sport, court_index, date, time, user_id)
      VALUES (?, ?, ?, ?, ?, ?)
    `).run(Number(clubId), String(sport), Number(courtIndex), String(date), String(time), Number(targetUserId));

    res.json({ ok: true });
  } catch (e) {
    console.error(e);
    if (String(e.message || '').includes('UNIQUE')) {
      return res.status(409).json({ error: 'slot already booked' });
    }
    res.status(500).json({ error: 'unexpected error' });
  }
});

app.post('/cancel', async (req, res) => {
  try {
    const { bookingId, userId } = req.body || {};
    if (bookingId == null || userId == null) return res.status(400).json({ error: 'bookingId, userId required' });

    const row = await db.prepare('SELECT club_id, user_id FROM bookings WHERE id = ?').get(Number(bookingId));
    if (!row) return res.status(404).json({ error: 'booking not found' });

    const clubRow = await db.prepare('SELECT manager_id FROM clubs WHERE id = ?').get(Number(row.club_id));
    const managerId = clubRow ? Number(clubRow.manager_id) : null;

    const isOwner = Number(row.user_id) === Number(userId);
    const isManager = managerId === Number(userId);

    if (!isOwner && !isManager) {
      return res.status(403).json({ error: 'not allowed' });
    }

    await db.prepare('DELETE FROM bookings WHERE id = ?').run(Number(bookingId));
    res.json({ ok: true });
  } catch (e) {
    console.error(e);
    res.status(500).json({ error: 'unexpected error' });
  }
});

// -------------------------------
// Server
// -------------------------------
await logDbIdentity();
const PORT = process.env.PORT || 5051;
app.listen(PORT, () => console.log(`server listening on :${PORT}`));


export default db